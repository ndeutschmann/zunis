#!/usr/bin/env python3

import random
import os
import sys
import vegas
import math
import torch
import logging
import numpy as np
from inspect import getsourcefile
import numpy as np
from torchps.flat_phase_space_generator import *
from utils.integrands.abstract import Integrand
from utils.integrands import sanitize_variable
from utils.integrands.mg.parse_params import ParseParams

logger = logging.getLogger(__name__)

class CrossSection(Integrand):
    """The matrix-element generated by the Fortran-output of MadGraph5_aMC@NLO"""
    
    def __init__(self, e_cm=1000, pdf=False, delr_cut=0.4,pt_cut=10, rap_maxcut=2.4, pdf_type=None, pdf_dir=None, lhapdf_dir=None, process=None, process_path=None, device=None, *args, **kwargs):  
        """

        Parameters
        ----------
        e_cm : float or torch.Tensor
            Centre-of-mass energy of a central two-body collision.
        pdf: boolean
            If True, the beams are assuemed to be proton beams and the PDFs are included in the calculation.
        delr_cut: float or torch.Tensor
            The minimum angular distance between each pair of the outgoing particles. 
        pt_cut: float or torch.Tensor
            The minimal transversal momentum of each outgoing particle.
        rap_maxcut: float or torch.Tensor
            The maximal rapidity of each outgoing particle. -1 means no cut.
        pdf_type: String
            The name of the PDF set to be used by LHAPDF.
        pdf_dir: String
            The directory whre the PDF data sets are stored.
        lhapdf_dir: String
            The path to the LHAPDF shared-object file.
        process: String
            The name given by MadGraph5_aMC@NLO to the subprocess.
        proces_path: String
            The path to the MadGraph5_aMC@NLO process directory.
        device: torch.device
            Default device where the parameters are stored
        """
        
        logger.debug(process)
        self.pdf=pdf
        self.pdf_obj=None
        self.process=process
        self.process_path=process_path
        
        #Try to import LHAPDF. If this is not possible, PDFs are not included
        if self.pdf and lhapdf_dir==None:
            logger.error("The directory of the LHAPDF module was not given. PDFs are not included")
            self.pdf=False
        if self.pdf:
            if lhapdf_dir not in sys.path:
                sys.path.append(lhapdf_dir)
            try:
                import lhapdf
                self.pdf_obj = lhapdf.mkPDF(pdf_type, 0)
            except Exception as e:
                logger.error("LHAPDF could not be imported")
                logger.debug(e)
                self.pdf=False
                
       
        #Try to import the matrix element shared-object file
        if self.process_path not in sys.path:
            sys.path.append(self.process_path+"/SubProcesses/"+self.process)
        try:
            import matrix2py
        except Exception as e:
            logger.error("The matrix elements could not be imported")
            logger.debug(e)
            
        self.process=process
        self.E_cm=sanitize_variable(e_cm,device)
        self.delR_cut=sanitize_variable(delr_cut,device)
        self.pT_cut=sanitize_variable(pt_cut,device)
        self.rap_maxcut=sanitize_variable(rap_maxcut,device)
        self.default_device=device

        
        
        #the matrix element needs to be initialised
        matrix2py.initialisemodel(self.process_path+"/Cards/param_card.dat")

        parser=ParseParams(self.process, self.process_path+"/SubProcesses/")
       
        (pdg, external_masses)=parser.parse()
 
        self.pdg=pdg
                

        logger.info("# ingoing particles: "+str(len(external_masses[0])))
        logger.info("Ingoing pdg codes: "+str(pdg[0])+" "+str(pdg[1]))
        logger.info("PDFs active: "+str(self.pdf))
        logger.info("# outgoing particles: "+str(len(external_masses[1])))

        if((len(external_masses[0]))!=2 and self.pdf):
            logger.info("No PDF support for other cases than 2 body collision")
            self.pdf=False
        
        #initialising of the phase space generator
        self.this_process_E_cm = max( self.E_cm, sum(external_masses[1])*2. )
        self.my_ps_generator=FlatInvertiblePhasespace(external_masses[0], external_masses[1],pdf=self.pdf_obj,pdf_active=self.pdf, lhapdf_dir=lhapdf_dir, tau=False)
        
        #determination of the #dof
        if not self.pdf:
            self.d = self.my_ps_generator.nDimPhaseSpace() # number of dimensions
        else:
            self.d = self.my_ps_generator.nDimPhaseSpace()+2 # number of dimensions
            
        super(CrossSection, self).__init__(self.d)


    def evaluate_integrand(self, x):
        #import the matrix element
        if self.process_path not in sys.path:
            sys.path.append(self.process_path)
        try:
            import matrix2py
        except:
            logger.error("The matrix elements could not be imported")
            
        #perform the phase-space sampling
        momenta, jac = self.my_ps_generator.generateKinematics_batch(self.this_process_E_cm, x,pT_mincut=self.pT_cut, delR_mincut=self.delR_cut, rap_maxcut=self.rap_maxcut, pdgs=self.pdg)
        #the matrix element can only be calculated on cpu so far
        momenta=momenta.cpu()
        jac=jac.cpu()
        element=[0]*momenta.shape[0]
        #calculate the matrix element for the generated phase space points
        element=[matrix2py.smatrix(momenta[ind,:,:].t().tolist())*jac[ind]
                for ind, q in enumerate(element)]
        
        #conversion in pb
        return torch.tensor(element,device=x.device)/(2.5681894616*10**(-9))
        
    

